var documenterSearchIndex = {"docs":
[{"location":"#MacroTools.jl-1","page":"Home","title":"MacroTools.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A library provides helpful tools for writing macros, notably a very simple but powerful templating system and some functions that have proven useful to me.","category":"page"},{"location":"#Template-Matching-1","page":"Home","title":"Template Matching","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Template matching enables macro writers to deconstruct Julia expressions in a more declarative way, and without having to know in great detail how syntax is represented internally. For example, say you have a type definition:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ex = quote\n  struct Foo\n    x::Int\n    y\n  end\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"If you know what you're doing, you can pull out the name and fields via:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> if isexpr(ex.args[2], :struct)\n         (ex.args[2].args[2], ex.args[2].args[3].args)\n       end\n(:Foo,{:( # line 3:),:(x::Int),:( # line 4:),:y})","category":"page"},{"location":"#","page":"Home","title":"Home","text":"But this is hard to write – since you have to deconstruct the type expression by hand – and hard to read, since you can't tell at a glance what's being achieved. On top of that, there's a bunch of messy stuff to deal with like pesky begin blocks which wrap a single expression, line numbers, etc. etc.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Enter MacroTools:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using MacroTools\n\njulia> @capture(ex, struct T_ fields__ end)\ntrue\n\njulia> T, fields\n(:Foo, [:(x::Int), :y])","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Symbols like T_ underscore are treated as catchalls which match any expression, and the expression they match is bound to the (underscore-less) variable, as above.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Because @capture doubles as a test as well as extracting values, you can easily handle unexpected input (try writing this by hand):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@capture(ex, f_{T_}(xs__) = body_) ||\n  error(\"expected a function with a single type parameter\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Symbols like f__ (double underscored) are similar, but slurp a sequence of arguments into an array. For example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> @capture(:[1, 2, 3, 4, 5, 6, 7], [1, a_, 3, b__, c_])\ntrue\n\njulia> a, b, c\n(2,[4,5,6],7)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Slurps don't have to be at the end of an expression, but like the Highlander there can only be one (per expression).","category":"page"},{"location":"#Matching-on-expression-type-1","page":"Home","title":"Matching on expression type","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"@capture can match expressions by their type, which is either the head of Expr objects or the typeof atomic stuff like Symbols and Ints. For example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@capture(ex, foo(x_String_string))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This will match a call to the foo function which has a single argument, which may either be a String object or a Expr(:string, ...) (e.g. @capture(:(foo(\"$(a)\")), foo(x_String_string))). Julia string literals may be parsed into either type of object, so this is a handy way to catch both.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Another common use case is to catch symbol literals, e.g.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@capture(ex,\n  struct T_Symbol\n    fields__\n  end)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"which will match e.g. struct Foo ... but not struct Foo{V} ...","category":"page"},{"location":"#Unions-1","page":"Home","title":"Unions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"@capture can also try to match the expression against one pattern or another, for example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@capture(ex, f_(args__) = body_ | function f_(args__) body_ end)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"will match both kinds of function syntax (though it's easier to use shortdef to normalise definitions). You can also do this within expressions, e.g.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"@capture(ex, (f_{T_}|f_)(args__) = body_)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"matches a function definition, with a single type parameter bound to T if possible. If not, T = nothing.","category":"page"},{"location":"#Expression-Walking-1","page":"Home","title":"Expression Walking","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"If you've ever written any more interesting macros, you've probably found yourself writing recursive functions to work with nested Expr trees. MacroTools' prewalk and postwalk functions factor out the recursion, making macro code much more concise and robust.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"These expression-walking functions essentially provide a kind of find-and-replace for expression trees. For example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using MacroTools: prewalk, postwalk\n\njulia> postwalk(x -> x isa Integer ? x + 1 : x, :(2+3))\n:(3 + 4)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In other words, look at each item in the tree; if it's an integer, add one, if not, leave it alone.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We can do more complex things if we combine this with @capture. For example, say we want to insert an extra argument into all function calls:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> ex = quote\n         x = f(y, g(z))\n         return h(x)\n       end\n\njulia> postwalk(x -> @capture(x, f_(xs__)) ? :($f(5, $(xs...))) : x, ex)\nquote  # REPL[20], line 2:\n    x = f(5, y, g(5, z)) # REPL[20], line 3:\n    return h(5, x)\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Most of the time, you can use postwalk without worrying about it, but we also provide prewalk. The difference is the order in which you see sub-expressions; postwalk sees the leaves of the Expr tree first and the whole expression last, while prewalk is the opposite.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> postwalk(x -> @show(x) isa Integer ? x + 1 : x, :(2+3*4));\nx = :+\nx = 2\nx = :*\nx = 3\nx = 4\nx = :(4 * 5)\nx = :(3 + 4 * 5)\n\njulia> prewalk(x -> @show(x) isa Integer ? x + 1 : x, :(2+3*4));\nx = :(2 + 3 * 4)\nx = :+\nx = 2\nx = :(3 * 4)\nx = :*\nx = 3\nx = 4","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A significant difference is that prewalk will walk into whatever expression you return.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> postwalk(x -> @show(x) isa Integer ? :(a+b) : x, 2)\nx = 2\n:(a + b)\n\njulia> prewalk(x -> @show(x) isa Integer ? :(a+b) : x, 2)\nx = 2\nx = :+\nx = :a\nx = :b\n:(a + b)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This makes it somewhat more prone to infinite loops; for example, if we returned :(1+b) instead of :(a+b), prewalk would hang trying to expand all of the 1s in the expression.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"With these tools in hand, a useful general pattern for macros is:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"macro foo(ex)\n  postwalk(ex) do x\n    @capture(x, some_pattern) || return x\n    return new_x\n  end\nend","category":"page"},{"location":"#Function-definitions-1","page":"Home","title":"Function definitions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"splitdef(def) matches a function definition of the form","category":"page"},{"location":"#","page":"Home","title":"Home","text":"function name{params}(args; kwargs)::rtype where {whereparams}\n   body\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"and returns Dict(:name=>..., :args=>..., etc.). The definition can be rebuilt by calling MacroTools.combinedef(dict), or explicitly with","category":"page"},{"location":"#","page":"Home","title":"Home","text":"rtype = get(dict, :rtype, :Any)\nall_params = [get(dict, :params, [])..., get(dict, :whereparams, [])...]\n:(function $(dict[:name]){$(all_params...)}($(dict[:args]...);\n                                            $(dict[:kwargs]...))::$rtype\n      $(dict[:body])\n  end)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"splitarg(arg) matches function arguments (whether from a definition or a function call) such as x::Int=2 and returns (arg_name, arg_type, slurp, default). default is nothing when there is none. For example:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"> map(splitarg, (:(f(y, a=2, x::Int=nothing, args...))).args[2:end])\n4-element Array{Tuple{Symbol,Symbol,Bool,Any},1}:\n (:y, :Any, false, nothing)  \n (:a, :Any, false, 2)        \n (:x, :Int, false, :nothing)\n (:args, :Any, true, nothing)","category":"page"},{"location":"#Function-and-Macros-1","page":"Home","title":"Function and Macros","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Modules = [MacroTools]\nOrder = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"#MacroTools.@esc-Tuple","page":"Home","title":"MacroTools.@esc","text":"@esc x y\n\nis the same as\n\nx = esc(x)\ny = esc(y)\n\n\n\n\n\n","category":"macro"},{"location":"#MacroTools.@expand-Tuple{Any}","page":"Home","title":"MacroTools.@expand","text":"More convenient macro expansion, e.g.\n\n@expand @time foo()\n\n\n\n\n\n","category":"macro"},{"location":"#MacroTools.inexpr-Tuple{Any,Any}","page":"Home","title":"MacroTools.inexpr","text":"inexpr(expr, x)\n\nSimple expression match; will return true if the expression x can be found inside expr.\n\ninexpr(:(2+2), 2) == true\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.isdef-Tuple{Any}","page":"Home","title":"MacroTools.isdef","text":"Test for function definition expressions.\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.isexpr-Tuple{Expr}","page":"Home","title":"MacroTools.isexpr","text":"isexpr(x, ts...)\n\nConvenient way to test the type of a Julia expression. Expression heads and types are supported, so for example you can call\n\nisexpr(expr, String, :string)\n\nto pick up on all string-like expressions.\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.namify-Tuple{Symbol}","page":"Home","title":"MacroTools.namify","text":"An easy way to get pull the (function/type) name out of expressions like foo{T} or Bar{T} <: Vector{T}.\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.prettify-Tuple{Any}","page":"Home","title":"MacroTools.prettify","text":"prettify(ex)\n\nMakes generated code generaly nicer to look at.\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.rmlines-Tuple{Any}","page":"Home","title":"MacroTools.rmlines","text":"rmlines(x)\n\nRemove the line nodes from a block or array of expressions.\n\nCompare quote end vs rmlines(quote end)\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.splitarg-Tuple{Any}","page":"Home","title":"MacroTools.splitarg","text":"splitarg(arg)\n\nMatch function arguments (whether from a definition or a function call) such as x::Int=2 and return (arg_name, arg_type, is_splat, default). arg_name and default are nothing when they are absent. For example:\n\n> map(splitarg, (:(f(a=2, x::Int=nothing, y, args...))).args[2:end])\n4-element Array{Tuple{Symbol,Symbol,Bool,Any},1}:\n (:a, :Any, false, 2)\n (:x, :Int, false, :nothing)\n (:y, :Any, false, nothing)\n (:args, :Any, true, nothing)\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.splitdef-Tuple{Any}","page":"Home","title":"MacroTools.splitdef","text":"splitdef(fdef)\n\nMatch any function definition\n\nfunction name{params}(args; kwargs)::rtype where {whereparams}\n   body\nend\n\nand return Dict(:name=>..., :args=>..., etc.). The definition can be rebuilt by calling MacroTools.combinedef(dict), or explicitly with\n\nrtype = get(dict, :rtype, :Any)\nall_params = [get(dict, :params, [])..., get(dict, :whereparams, [])...]\n:(function $(dict[:name]){$(all_params...)}($(dict[:args]...);\n                                            $(dict[:kwargs]...))::$rtype\n      $(dict[:body])\n  end)\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.unblock-Tuple{Any}","page":"Home","title":"MacroTools.unblock","text":"unblock(expr)\n\nRemove outer begin blocks from an expression, if the block is redundant (i.e. contains only a single expression).\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.@>-Tuple","page":"Home","title":"MacroTools.@>","text":"The threading macro is like a more flexible version of the |> operator.\n\n@> x f = f(x)\n@> x g f == f(g(x))\n@> x a b c d e == e(d(c(b(a(x)))))\n\nUnlike |>, functions can have arguments - the value preceding a function will be treated as its first argument\n\n@> x g(y, z) f == f(g(x, y, z))\n\n@> x g f(y, z) == f(g(x), y, z)\n\nSee also @>>, @as.\n\n\n\n\n\n","category":"macro"},{"location":"#MacroTools.@>>-Tuple","page":"Home","title":"MacroTools.@>>","text":"Same as @>, but threads the last argument.\n\n@>> x g(y, z) f == f(g(y, z, x))\n\n@>> x g f(y, z) == f(y, z, g(x))\n\n\n\n\n\n","category":"macro"},{"location":"#MacroTools.@forward-Tuple{Any,Any}","page":"Home","title":"MacroTools.@forward","text":"@forward Foo.bar f, g, h\n\n@forward simply forwards method definition to a given field of a struct. For example, the above is  equivalent to\n\nf(x::Foo, args...) = f(x.bar, args...)\ng(x::Foo, args...) = g(x.bar, args...)\nh(x::Foo, args...) = h(x.bar, args...)\n\n\n\n\n\n","category":"macro"},{"location":"#MacroTools.@q-Tuple{Any}","page":"Home","title":"MacroTools.@q","text":"@q [expression]\n\nLike the quote keyword but doesn't insert line numbers from the construction site. e.g. compare @q begin end with quote end. Line numbers of interpolated expressions are preserverd.\n\n\n\n\n\n","category":"macro"},{"location":"#MacroTools.alias_gensyms-Tuple{Any}","page":"Home","title":"MacroTools.alias_gensyms","text":"alias_gensyms(expr)\n\nReplaces gensyms with animal names This makes gensym'd code far easier to follow.\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.assoc!-Tuple{Any,Any,Any}","page":"Home","title":"MacroTools.assoc!","text":"assoc!(d, k, v)\n\nis the same as d[k] = v but returns d rather than v.\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.combinearg-NTuple{4,Any}","page":"Home","title":"MacroTools.combinearg","text":"combinearg(arg_name, arg_type, is_splat, default)\n\ncombinearg is the inverse of splitarg. \n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.combinedef-Tuple{Dict}","page":"Home","title":"MacroTools.combinedef","text":"combinedef(dict::Dict)\n\ncombinedef is the inverse of splitdef. It takes a splitdef-like Dict and returns a function definition. \n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.gatherwheres-Tuple{Any}","page":"Home","title":"MacroTools.gatherwheres","text":"gatherwheres(:(f(x::T, y::U) where T where U)) => (:(f(x::T, y::U)), (:U, :T))\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.gensym_ids-Tuple{Any}","page":"Home","title":"MacroTools.gensym_ids","text":"gensym_ids(expr)\n\nReplaces gensyms with unique ids (deterministically)\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.postwalk-Tuple{Any,Any}","page":"Home","title":"MacroTools.postwalk","text":"postwalk(f, expr)\n\nApplies f to each node in the given expression tree, returning the result. f sees expressions after they have been transformed by the walk. See also prewalk.\n\n\n\n\n\n","category":"method"},{"location":"#MacroTools.prewalk-Tuple{Any,Any}","page":"Home","title":"MacroTools.prewalk","text":"prewalk(f, expr)\n\nApplies f to each node in the given expression tree, returning the result. f sees expressions before they have been transformed by the walk, and the walk will be applied to whatever f returns.\n\nThis makes prewalk somewhat prone to infinite loops; you probably want to try postwalk first.\n\n\n\n\n\n","category":"method"}]
}
