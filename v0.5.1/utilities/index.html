<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Utilities · MacroTools</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MacroTools</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../pattern-matching/">Pattern Matching</a></li><li><a class="toctext" href="../sourcewalk/">SourceWalk</a></li><li class="current"><a class="toctext" href>Utilities</a><ul class="internal"><li><a class="toctext" href="#Function-definitions-1">Function definitions</a></li><li><a class="toctext" href="#Other-Utilities-1">Other Utilities</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Utilities</a></li></ul><a class="edit-page" href="https://github.com/MikeInnes/MacroTools.jl/blob/master/docs/src/utilities.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Utilities</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h1><h2><a class="nav-anchor" id="Function-definitions-1" href="#Function-definitions-1">Function definitions</a></h2><p>Function definitions pose a problem to pattern matching, since there are a lot of different ways to define a function. For example, a pattern that captures <code>f(x) = 2x</code> will not match</p><pre><code class="language-julia">function f(x)
  return 2x
end</code></pre><p>There are a couple of ways to handle this. One way is to use <code>longdef</code> or <code>shortdef</code> to normalise function definitions to short form, before matching it.</p><pre><code class="language-julia">julia&gt; ex = :(function f(x) 2x end)
:(function f(x)
      #= none:1 =#
      2x
  end)

julia&gt; MacroTools.shortdef(ex)
:(f(x) = begin
          #= none:1 =#
          2x
      end)</code></pre><p>More generally it&#39;s also possible to use <code>splitdef</code> and <code>combinedef</code> to handle the full range of function syntax.</p><p><code>splitdef(def)</code> matches a function definition of the form</p><pre><code class="language-julia">function name{params}(args; kwargs)::rtype where {whereparams}
   body
end</code></pre><p>and returns <code>Dict(:name=&gt;..., :args=&gt;..., etc.)</code>. The definition can be rebuilt by calling <code>MacroTools.combinedef(dict)</code>, or explicitly with</p><pre><code class="language-julia">rtype = get(dict, :rtype, :Any)
all_params = [get(dict, :params, [])..., get(dict, :whereparams, [])...]
:(function $(dict[:name]){$(all_params...)}($(dict[:args]...);
                                            $(dict[:kwargs]...))::$rtype
      $(dict[:body])
  end)</code></pre><p><code>splitarg(arg)</code> matches function arguments (whether from a definition or a function call) such as <code>x::Int=2</code> and returns <code>(arg_name, arg_type, slurp, default)</code>. <code>default</code> is <code>nothing</code> when there is none. For example:</p><pre><code class="language-julia">&gt; map(splitarg, (:(f(y, a=2, x::Int=nothing, args...))).args[2:end])
4-element Array{Tuple{Symbol,Symbol,Bool,Any},1}:
 (:y, :Any, false, nothing)  
 (:a, :Any, false, 2)        
 (:x, :Int, false, :nothing)
 (:args, :Any, true, nothing)</code></pre><h2><a class="nav-anchor" id="Other-Utilities-1" href="#Other-Utilities-1">Other Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.isexpr" href="#MacroTools.isexpr"><code>MacroTools.isexpr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">isexpr(x, ts...)</code></pre><p>Convenient way to test the type of a Julia expression. Expression heads and types are supported, so for example you can call</p><pre><code class="language-none">isexpr(expr, String, :string)</code></pre><p>to pick up on all string-like expressions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.rmlines" href="#MacroTools.rmlines"><code>MacroTools.rmlines</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rmlines(x)</code></pre><p>Remove the line nodes from a block or array of expressions.</p><p>Compare <code>quote end</code> vs <code>rmlines(quote end)</code></p><p><strong>Examples</strong></p><p>To work with nested blocks:</p><pre><code class="language-julia">prewalk(rmlines, ex)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.unblock" href="#MacroTools.unblock"><code>MacroTools.unblock</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unblock(expr)</code></pre><p>Remove outer <code>begin</code> blocks from an expression, if the block is redundant (i.e. contains only a single expression).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.namify" href="#MacroTools.namify"><code>MacroTools.namify</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>An easy way to get the (function/type) name out of expressions like <code>foo{T}</code> or <code>Bar{T} &lt;: Vector{T}</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.inexpr" href="#MacroTools.inexpr"><code>MacroTools.inexpr</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">inexpr(expr, x)</code></pre><p>Simple expression match; will return <code>true</code> if the expression <code>x</code> can be found inside <code>expr</code>.</p><pre><code class="language-none">inexpr(:(2+2), 2) == true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.gensym_ids" href="#MacroTools.gensym_ids"><code>MacroTools.gensym_ids</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">gensym_ids(expr)</code></pre><p>Replaces gensyms with unique ids (deterministically).</p><pre><code class="language-none">julia&gt; x, y = gensym(&quot;x&quot;), gensym(&quot;y&quot;)
(Symbol(&quot;##x#363&quot;), Symbol(&quot;##y#364&quot;))

julia&gt; MacroTools.gensym_ids(:($x+$y))
:(x_1 + y_2)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.alias_gensyms" href="#MacroTools.alias_gensyms"><code>MacroTools.alias_gensyms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">alias_gensyms(expr)</code></pre><p>Replaces gensyms with animal names. This makes gensym&#39;d code far easier to follow.</p><pre><code class="language-none">julia&gt; x, y = gensym(&quot;x&quot;), gensym(&quot;y&quot;)
(Symbol(&quot;##x#363&quot;), Symbol(&quot;##y#364&quot;))

julia&gt; MacroTools.alias_gensyms(:($x+$y))
:(porcupine + gull)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.@expand" href="#MacroTools.@expand"><code>MacroTools.@expand</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><p>More convenient macro expansion, e.g.</p><pre><code class="language-none">@expand @time foo()</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.isdef" href="#MacroTools.isdef"><code>MacroTools.isdef</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Test for function definition expressions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.flatten" href="#MacroTools.flatten"><code>MacroTools.flatten</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">flatten(ex)</code></pre><p>Flatten any redundant blocks into a single block, over the whole expression.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MacroTools.prettify" href="#MacroTools.prettify"><code>MacroTools.prettify</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">prettify(ex)</code></pre><p>Makes generated code generaly nicer to look at.</p></div></div></section><footer><hr/><a class="previous" href="../sourcewalk/"><span class="direction">Previous</span><span class="title">SourceWalk</span></a></footer></article></body></html>
